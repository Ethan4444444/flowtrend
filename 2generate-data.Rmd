# 1d data

## Generating 1d data

This function generates synthetic 1-dimensional data, and returns it in a "long"
format matrix, with columns `time`, `y`, `mu`, and `cluster`. The latter two are
the true underlying parameters.

```{r gendat_1d}
#' Generates some synthetic 1-dimensional data with three clusters. Returns a
#' data frame with (1) time, (2) Y (3) mu (4) cluster assignments.
#'
#' @param TT Number of time points.
#' @param nt Number of particles at each time.
#' @param offset Defaults to 0. How much to push up cluster 1.
#' @param return_model If true, return true cluster means and probabilities
#'   instead of data.
#'
#' @return long matrix with data or model.
#' @export
gendat_1d <- function(TT, ntlist, offset = 0, return_model = FALSE,
                      sd3=NULL){

  ## Basic checks
  stopifnot(length(ntlist) == TT)
  prob_link1 = rep(NA, TT)
  prob_link1[1] = 2
  for(tt in 2:floor(TT/2)){
    prob_link1[tt] = prob_link1[tt-1] + (1/TT)
  }
  for(tt in (floor(TT/2)+1):TT){
    prob_link1[tt] = prob_link1[tt-1] - .5*(1/TT)
  }
  prob_link2 = sapply(1:TT, function(tt) 3 - 0.25*(tt/TT))
  prob_link3 = sapply(1:TT, function(tt) 2.5)
  linkmat = cbind(prob_link1, prob_link2, prob_link3) ##%>% matplot()
  mysum = exp(linkmat) %>% rowSums()
  cluster_prob1 = exp(prob_link1) / mysum
  cluster_prob2 = exp(prob_link2) / mysum
  cluster_prob3 = exp(prob_link3) / mysum
  probs = cbind(cluster_prob1, cluster_prob2, cluster_prob3)
  colnames(probs) = 1:3
  sd1 = 0.4
  sd2 = 0.5
  if(is.null(sd3)) sd3 = 0.35
  ## if(!is.null(sd3)) sd3 = 1/1.5 ## The ratio of amplitude:data-standard-deviation is about
  ##             ## $1.50695$.
  probs_long = as_tibble(probs) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "prob")
  probs_long %>% ggplot() + geom_line(aes(x=time,y=prob, group=cluster, col=cluster)) + ylim(c(0,1))

  ## Make cluster means, by time
  means <- matrix(NA, TT, 3)
  for(ii in 1:3){
    for(tt in 1:TT){
      means[tt, 1] <- offset + tt/TT - 1.5
      means[tt, 2] <- sin(seq(-1, 1, length.out = TT)[tt] * 3.1415)
      means[tt, 3] <- -3+sin(seq(-1, 1, length.out = TT)[tt] * 6.282)
    }
  }
  colnames(means) = c(1:3)
  means_long = as_tibble(means) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "mean")
  model = full_join(means_long, probs_long, by = c("time", "cluster"))
  model = model %>% left_join(tibble(cluster = c("1", "2", "3"),
                                     sd = c(sd1, sd2, sd3)),
                              by = "cluster") ## Does this work?
  if(return_model) return(model)

  ys <- lapply(1:TT, FUN = function(tt){

    Y <- vector(mode = "list", length = 2)
    mu <- vector(mode = "list", length = 2)
    clusters_count <- rmultinom(n = 1, size = ntlist[tt], prob = probs[tt,])

    for(ii in 1:3){
      if(ii == 1){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd1))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
      if(ii == 2){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd2))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
      if(ii == 3){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd3))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
    }
    Y <- unlist(Y)
    mu <- unlist(mu)
    cluster <- rep(1:3, times = clusters_count)
    one_df = tibble(time = tt, Y = Y, mu = mu, cluster = cluster)
    return(one_df)
  }) %>% bind_rows()
  return(ys)
}
```


`dt2ylist()` is a helper that takes the output generated from `gendat_1d()`, and
splits it by the `time` column to create a `ylist` object, which is a $T$-length
list of $n_t \times d$ matrices.

```{r dt2ylist}
#' Converting to a list of matrices, \code{ylist}, to input to \code{flowtrend()}.
#'
#' @param dt Output from \code{gendat_1d()}.
#'
#' @return List of matrices
#' @export
dt2ylist <- function(dt){
  dt%>% dplyr::select(time, Y) %>% arrange(time) %>%
    group_by(time) %>%
    group_split(.keep = FALSE) %>%
    lapply(as.matrix)
}
```

Let's generate some data using these functions.

```{r test-generate-data}
dt = gendat_1d(TT = 100, ntlist =rep(100,100))
print(dt)
```

```{r test-ylist}
ylist = dt2ylist(dt)
print(head(str(ylist[1:5])))
```

```{r test-ylist2}
print(head(ylist[[1]]))
```

Next, we'll make some plotting functions 1d model and data.


## Plotting 1d data

Given 1d data `ylist` and an estimated model object `obj`, we want to plot both
in a single plot. `plot_1d()` lets you do this.

```{r plot_1d}
#' Makes 1d plot of data and model
#'
#' @param ylist Data.
#' @param obj flowtrend object. Defaults to NULL.
#' @param x time points. Defaults to NULL.
#' @param add_point if TRUE, add the means as points.
#' @param idim if provided, take the idim.
#'
#' @return ggplot object with data, and optionally, a flowtrend model overlaid.
#' @export
plot_1d <- function(ylist, countslist=NULL, obj=NULL, x = NULL, add_point = FALSE, idim = NULL, alpha = .1){

  ## Basic checks
  if(!is.null(x)){
    stopifnot(length(x) == length(ylist))
    times = x
  } else {
    times = 1:length(ylist)
  }


  ## If more than 2d data is provided, take the idim'th info only.
  dimdat = ncol(ylist[[1]])
  if(dimdat >= 2){
    assertthat::assert_that(!is.null(idim))
    assertthat::assert_that(idim %in% 1:dimdat)

    if(!is.null(obj)){
      obj$mn = obj$mn %>% .[,idim,,drop=FALSE]
      obj$sigma = obj$sigma %>% .[,idim,idim,drop=FALSE]
    }
    ylist = ylist %>% lapply(function(a) a[,idim, drop=FALSE])
  }

  if(is.null(countslist)){
    ## make data into long matrix
    ymat <- lapply(1:length(ylist), FUN = function(tt){
      data.frame(time = times[tt], Y = ylist[[tt]])
    }) %>% bind_rows() %>% as_tibble()
    colnames(ymat) = c("time", "Y", "counts") ## when ylist[[tt]] already has a column name, this is needed.

    ## plot long matrix
    gg = ymat %>% ggplot() +
      geom_point(aes(x = time, y = Y), alpha = alpha) +
      theme_bw() + ylab("Data") + xlab("Time") 
      ## theme(legend.position = 'none')
  } else {
    ## make data into long matrix
    ymat <- lapply(1:length(ylist), FUN = function(tt){
      data.frame(time = times[tt], Y = ylist[[tt]], counts = countslist[[tt]])
    }) %>% bind_rows() %>% as_tibble()
    colnames(ymat) = c("time", "Y", "counts") ## when ylist[[tt]] already has a column name, this is needed.

    ## plot long matrix
    gg = ymat %>% ggplot() +
      geom_raster(aes(x = time, y = Y, fill = counts)) +
      theme_bw() + ylab("Data") + xlab("Time")  +
      scale_fill_gradientn(colours = c("white", "black"))
      ## theme(legend.position = 'none')
  }
  if(is.null(obj)){
    return(gg)
  } else {
  
    ## Add the model
    numclust = obj$numclust
    mnmat = obj$mn %>% .[,1,] %>%  `colnames<-`(1:numclust) %>% as_tibble() %>% 
      add_column(time = times)
    probmat = obj$prob %>% as_tibble() %>% setNames(1:numclust) %>% add_column(time = times)
    mn_long = mnmat %>% pivot_longer(-time, names_to = "cluster", values_to = "mean")
    prob_long = probmat %>% pivot_longer(-time, names_to = "cluster", values_to = "prob")
    est_long = full_join(mn_long, prob_long, by = c("time","cluster"))
    gg = gg + geom_path(aes(x = time, y = mean, linewidth = prob, group = cluster, color = cluster),
                        data = est_long,
                        lineend = "round", linejoin="mitre")
    if(add_point){
      gg = gg + geom_line(aes(x = time, y = mean, linewidth = prob, group = cluster),
                          data = est_long, size = rel(1),
                          col = 'black')
    }
  
    ## TODO: make it ignore the missing values at the gaps; currently this is not coded as NAs.
  
    ## Add the estimated 95% probability regions for data.
    stdev = obj$sigma %>% .[,,1] %>% sqrt()
    ## band_long =
    ##   mn_long %>% mutate(upper = case_when(cluster == "1" ~ mean + 1.96 * stdev[1],
    ##                                        cluster == "2" ~ mean + 1.96 * stdev[2],
    ##                                        cluster == "3" ~ mean + 1.96 * stdev[3]),
    ##                      lower = case_when(cluster == "1" ~ mean - 1.96 * stdev[1],
    ##                                        cluster == "2" ~ mean - 1.96 * stdev[2],
    ##                                        cluster == "3" ~ mean - 1.96 * stdev[3]))

    mn_long_by_clust = mn_long %>% group_by(cluster) %>% group_split()
    band_long_by_clust = lapply(1:numclust, function(iclust){
      mn_long_by_clust[[iclust]] %>% mutate(upper = mean + 1.96 * stdev[iclust]) %>% mutate(lower = mean - 1.96 * stdev[iclust])
    })
    band_long = band_long_by_clust %>% bind_rows()


    gg + geom_line(aes(x = time, y = upper, group = cluster, color = cluster),
                   data = band_long, size = rel(.7), alpha = .5) +
      geom_line(aes(x = time, y = lower, group = cluster, color = cluster),
                data = band_long, size = rel(.7), alpha = .5) +
      guides(size = "none") # To turn off line size from legend
  }
}
```

The plotting function `plot_1d()` will be even more useful when we have a model,
but can also simply plot the data `ylist`. Let's try this out.

```{r test-gendat}
set.seed(100)
dt       <- gendat_1d(100, rep(100, 100))
dt_model <- gendat_1d(100, rep(100, 100), return_model = TRUE)
ylist = dt %>% dt2ylist()
x = dt %>% pull(time) %>% unique()

plot_1d(ylist, NULL, x = x) +
  geom_line(aes(x = time, y = mean, group = cluster),
            data = dt_model,
            linetype = "dashed", size=2, alpha = .7)
```
Voil√†!

Also, we will want to plot the estimated cluster probabilities of a model `obj`.

```{r}
#' Makes cluster probability plot (lines over time).
#'
#' @param obj Estimated model (from e.g. \code{flowtrend()})
#'
#' @export
plot_prob <- function(obj, x = NULL){

  ## Basic checks
  if(!is.null(x)){
    times = x
  } else {
    stop("must provide x")
    times = 1:length(ylist)
  }

  numclust = obj$numclust
  probmat = obj$prob %>% as_tibble() %>% setNames(1:numclust) %>% add_column(time = times)
  prob_long = probmat %>% pivot_longer(-time, names_to = "cluster", values_to = "prob")
  prob_long %>% ggplot() +
    geom_line(aes(x=time, y = prob, group = cluster, col = cluster), size = rel(1)) +
    ggtitle("Estimated cluster probability")
}
```

We can't test it out now, but we'll use it later in [1d-example](#1d-example).



# 2d data

## Generating 2d data


```{r gendat_2d}
#' Generates some synthetic 2-dimensional data with three clusters. 
#'
#' @param TT Number of time points.
#' @param nt Number of particles at each time.
#'
#' @return List containing (1) ylist, (2) mnlist, (3) clusterlist.
#' @export
gendat_2d <- function(TT, ntlist){


  ## Basic checks
  stopifnot(length(ntlist) == TT)

  ## Make cluster probabilities, by time
  cluster_prob1 = sapply(1:TT, function(tt) sin(tt/24 * 2 * pi)/3 + 1 + (tt/TT)*5)
  cluster_prob2 = sapply(1:TT, function(tt) cos(tt/24 * 2 * pi)/3 + 8 - (tt/TT)*5)
  cluster_prob3 = rep(3, TT)
  probs = cbind(cluster_prob1, cluster_prob2, cluster_prob3)
  probs = probs/rowSums(probs)
  colnames(probs) = 1:3
  probs_long = as_tibble(probs) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "prob")
  probs_long %>% ggplot() + geom_line(aes(x=time,y=prob, group=cluster, col=cluster)) + ylim(c(0,1))

  ## Make cluster means, by time
  means <- array(NA, dim = c(TT, 3, 2))
  for(ii in 1:3){
    for(tt in 1:TT){
      means[tt, 1, 1] = means[tt, 1, 2] = tt/TT + 0.5
      means[tt, 2, 1]  = sin(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*3.1415)
      means[tt, 2, 2] = 0
      means[tt, 3, 1] = means[tt, 3, 2] = -3+cos(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*6.282)
    }
  }
  dimnames(means)[[2]]  = c(1:3)
  means_long = as_tibble(means) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "mean")
  model = full_join(means_long, probs_long, by = c("time", "cluster"))

  ylist = list()
  mulist = list()
  clusterlist = list()
  for(tt in 1:TT){
    Y <- vector(mode = "list", length = 2)
    mu <- vector(mode = "list", length = 2)
    clusters_count <- rmultinom(n = 1, size = ntlist[tt], prob = probs[tt,])

    for(ii in 1:3){
      if(ii == 1){
        mn = means[tt,ii,,drop=TRUE]
        Sigma1 = matrix(c(0.4, 0.3, 0.3, 0.4), ncol = 2)
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma= Sigma1)) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 2){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma = diag(c(0.5, 0.1)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 3){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma = diag(c(0.35, 0.35)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
    }

    Y <- Y %>% purrr::compact() %>% do.call(rbind, .)
    mu <- mu %>% purrr::compact() %>% do.call(rbind, .)
    cluster <- rep(1:3, times = clusters_count)
    ylist[[tt]] = Y
    mulist[[tt]] = mu
    clusterlist[[tt]] = cluster
  }
  return(list(ylist = ylist, mulist = mulist,
              clusterlist = clusterlist,
              probs = probs, means = means))
}
```


## Plotting 2d data

Here's a simpler plotting function for 2d data at the particle level.

```{r}
#' Simple plotter for 2d particle data.
#' 
#' @param ylist data
#' @param countslist data
#' @param obj flowtrend (or flowmix) object.
#' @param time Out of 1 through \code{lengthy(list)}, which time point to plot.
#' 
#' @export
#' @return ggplot object.
plot_2d <- function(ylist, countslist = NULL, obj = NULL, tt,
                    point_color = "blue", raster_colours = c("white", "blue")){

  ## Basic checks
  stopifnot(ncol(ylist[[1]]) == 2)
  if(!is.null(obj)) stopifnot(obj$dimdat == 2)


  ## Take data from one time point
  y = ylist %>% .[[tt]]
  if(is.null(colnames(y))){ colnames(y) = paste0("dim", c(1,2)) }
  y = y %>% as_tibble()

  ## Get variable names
  ## colnames(ylist[[1]]) = c("","","")
  varnames = y %>% colnames()
  varname1 = varnames[1]
  varname2 = varnames[2]

  if(is.null(countslist)){

    ## Make a simple scatterplot
    p = y %>% ggplot() +
      geom_point(aes(x = !!sym(varname1), y=!!sym(varname2)), alpha = .2, col = "blue") +
      theme_minimal() +
      theme(legend.position = "none") 

  } else {
    ## Get data from one timepoint
    counts = countslist[[tt]]
    y = y %>% add_column(counts = counts)

    ## Make a simple scatterplot
    p = y %>% ggplot() +
      geom_raster(aes(x = !!sym(varname1), y=!!sym(varname2), fill = counts)) +
      scale_fill_gradientn(guide="none", colours = colours) 
  }

  p = p + ggtitle(paste0("Time=", tt))

  ## Adding visualizations of the model |obj|
  if(is.null(obj)){
    return(p)
  } else {
    mnlist = lapply(1:obj$numclust, function(iclust){
      one_mnmat = obj$mn[,,iclust]
      colnames(one_mnmat) = paste0("dim", 1:2)
      one_mnmat %>% as_tibble() %>% add_column(cluster = iclust)
    })
    mnmat = do.call(rbind, mnlist)

    mn_colours = rep("red", obj$numclust)
    for(iclust in 1:obj$numclust){

      ## Add ellipse
      el = ellipse::ellipse(x = obj$sigma[iclust,,],
                            centre = obj$mn[tt,,iclust]) %>% as_tibble()
      p = p + geom_path(aes(x = x, y = y), data = el,
                        colour = mn_colours[iclust], lty = 2,
                        linewidth = pmin(obj$prob[tt,iclust] * 8, 0.8))

      ## Add mean
      p = p + geom_point(aes(x = dim1, y = dim2),
                         data = mnmat %>% subset(cluster == iclust) %>% .[tt,],
                         colour = mn_colours[iclust],
                         ## size = rel(3))
                         size = obj$prob[tt,iclust] * 10)
    }
  }
  return(p)
}



## This is from the many-cruises 02-helpers.R file; come back to this.
if(FALSE){
  p = datobj_2d %>%
    ggplot() +
    theme_minimal() +
    geom_raster(aes(x = !!sym(varname1), y=!!sym(varname2), fill = counts)) +
    scale_fill_gradientn(colours = colours, guide="colorbar")+
    xlim(c(0,8)) + ylim(c(0, 8)) +
    theme(legend.position = "none")
}
```

Let's try it out.

```{r, fig.width = 5, fig.height = 5}
datobj = gendat_2d(2, c(1000,1000))
plot_2d(datobj$ylist, tt=1)
```




# 3d data

Given 3d data `ylist` and an estimated model object `obj`, we want to plot both
in three two-dimensional plot. `plot_3d()` lets you do this.

First, here's a plotting helper.

```{r}
#' Combine list of ggplots
#' @export
my_mfrow <- function(glist, ncol = NULL, nrow = NULL){
  if(is.null(ncol)) ncol = 1
  if(is.null(nrow)) ncol = 3
  do.call(ggpubr::ggarrange, c(glist, ncol=ncol, nrow=nrow))
}
```


(TODO: change tt to time (and all the user-facing functions should have the same
arguments and argument order))

```{r}
#' Makes three 2-dimensional plots of the 3d data
#' @param ylist data
#' @param countslist data
#' @param obj flowmix or flowtrend object
#' @param tt Time point
#' @param return_list_of_plots If TRUE, return the list of three plots instead
#'   of the combined plot
#' @export
#' @return
#' 
plot_3d <- function(ylist, obj = NULL, tt, countslist = NULL,
                    return_list_of_plots = FALSE){

  ## Basic checks
  stopifnot(ncol(ylist[[1]]) == 3)

  ## Extract data
  ## y = ylist[[tt]][,dims]
  labs = colnames(ylist[[1]])
  if(is.null(labs))  labs = paste0("dim", 1:3)
  if(is.null(countslist)){
    counts = rep(1, nrow(ylist[[1]]))
  }

  ## Aggregate counts into the two dimensions
  y2d_list = list()
  counts2d_list = list()
  for(ii in 1:3){
    dims = list(c(1:2), c(2:3), c(3,1))[[ii]]
    yy = flowmix::collapse_3d_to_2d(ylist[[tt]], countslist[[tt]], dims)
    y2d = yy[,1:2]
    colnames(y2d) = labs[dims]
    y2d_list[[ii]] = y2d
    counts2d_list[[ii]] = yy[,3]
  }
  total_range = sapply(counts2d_list, range) %>% range()

  ## Create three 2d plots
  plotlist = list()
  for(ii in 1:3){
    dims = list(c(1:2), c(2:3), c(3,1))[[ii]]

    ## Make data plot
    one_countslist = (if(!is.null(countslist)) list(counts2d_list[[ii]]) else NULL)
    p = flowtrend::plot_2d(list(y2d_list[[ii]]),
                           one_countslist, obj=NULL, 1) 
    if(!is.null(countslist)){
      p = p + scale_fill_gradientn(
                  colors = c("white", "blue", "yellow"), limits = total_range,
                  guide = "none")
    }

    ## Adding visualizations of the model |obj| at time tt
    if(!is.null(obj)){
      
      ## Make data matrix
      mnlist = lapply(1:obj$numclust, function(iclust){
        one_mnmat = obj$mn[tt,dims,iclust] %>% t()
        colnames(one_mnmat) = paste0("dim", 1:2)
        one_mnmat %>% as_tibble() %>% add_column(cluster = iclust)
      })
      mnmat = do.call(rbind, mnlist)
      mn_colours = rep("red", obj$numclust)

      for(iclust in 1:obj$numclust){
        
        ## Add ellipse
        el = ellipse::ellipse(x = obj$sigma[iclust,dims,dims],
                              centre = obj$mn[tt,dims,iclust]) %>% as_tibble()
        p = p + geom_path(aes(x = x, y = y), data = el,
                          colour = mn_colours[iclust], lty = 2,
                          linewidth = pmin(obj$prob[tt,iclust] * 8, 0.8))
        
        ## Add mean
        p = p + geom_point(aes(x = dim1, y = dim2),
                           data = mnmat %>% subset(cluster == iclust),
                           colour = mn_colours[iclust],
                           size = obj$prob[tt,iclust] * 10)

        ## Add cluster number as a label
        cex = rel(3)
        fac = 10
        labels = 1:(obj$numclust)
        dt = data.frame(dim1 = mnmat[,1], dim2 = mnmat[,2], prob = obj$prob[tt,] * fac)
        p = p + ggrepel::geom_text_repel(aes(x = dim1, y = dim2, label = labels,
                                             point.size = sqrt(prob)),
                                         col = mn_colours,
                                         cex = cex,
                                         bg.color = "white",
                                         bg.r = 0.1,
                                         fontface = "bold",
                                         force_pull   = 5, # do not pull toward data points
                                         ## data = mnmat,
                                         data = dt,
                                         seed = 1)

      }
    }

    ## Format a bit more and save
    if(ii == 1){
      p = p + ggtitle(paste0("Time=", tt))
    } else {
      p = p + ggtitle("")
    }
    p = p + theme(legend.position = "none") 
    plotlist[[ii]] = p
  }

  p_combined = my_mfrow(plotlist)

  ## Return the plots
  if(return_list_of_plots) return(plotlist)
  return(p_combined)
}
```
	
(This is test code.)

```{r, eval = FALSE}
litr::load_all("~/repos/flowtrend/index.Rmd")
load("~/repos/flowmix/paper-data/MGL1704-hourly-only-binned.Rdata", verbose=TRUE)
load("~/repos/flowmix/paper-data/cvres-2-64-10.Rdata", verbose=TRUE)

## Shift/scale data to make it equivalent to what the model used for fitting.
range.diam = c(-0.6706111,  1.3070264)
range.chl =  c(0.101313, 7.955767)
range.pe = c(0.101313, 7.955767)
ybin_list = lapply(ybin_list, function(y){
  y[,1]  = y[,1] - min(range.diam)
  y[,1] = y[,1] / width.diam
  y[,1] = y[,1] * max(range.chl)
  return(y)
})

## For back-compatibility
res = cvres$bestres
res$prob = res$pie

## Make the plot
plot_3d(ylist = ybin_list, countslist = biomass_list, obj = res, tt = 280)
```

```{r}
#' Generates some synthetic 3-dimensional data with three clusters. 
#'
#' @param TT Number of time points.
#' @param nt Number of particles at each time.
#'
#' @return List containing (1) ylist, (2) mnlist, (3) clusterlist.
#' @export
gendat_3d <- function(TT, ntlist){

  ## Basic checks
  stopifnot(length(ntlist) == TT)

  ## Make cluster probabilities, by time
  cluster_prob1 = sapply(1:TT, function(tt) sin(tt/24 * 2 * pi)/3 + 1 + (tt/TT)*5)
  cluster_prob2 = sapply(1:TT, function(tt) cos(tt/24 * 2 * pi)/3 + 8 - (tt/TT)*5)
  cluster_prob3 = rep(3, TT)
  probs = cbind(cluster_prob1, cluster_prob2, cluster_prob3)
  probs = probs/rowSums(probs)
  colnames(probs) = 1:3
  probs_long = as_tibble(probs) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "prob")
  probs_long %>% ggplot() + geom_line(aes(x=time,y=prob, group=cluster, col=cluster)) + ylim(c(0,1))

  ## Make cluster means, by time
  numclust = 3
  dimdat = 3
  ## means <- array(NA, dim = c(TT, 3, 2))
  means <- array(NA, dim = c(TT, numclust, dimdat))
  for(ii in 1:3){
    for(tt in 1:TT){

      ## First cluster 
      means[tt, 1, 1] = means[tt, 1, 2] = means[tt, 1, 3] = tt/TT + 0.5

      ## Second cluster 
      means[tt, 2, 1]  = sin(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*3.1415)
      means[tt, 2, 2] = 0
      means[tt, 2, 3] = 0

      ## Third cluster
      means[tt, 3, 1] = means[tt, 3, 2] = means[tt, 3, 3] =
        -3+cos(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*6.282)
    }
  }
  dimnames(means)[[2]]  = c(1:3)
  means_long = as_tibble(means) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "mean")
  model = full_join(means_long, probs_long, by = c("time", "cluster"))

  ylist = list()
  mulist = list()
  clusterlist = list()
  for(tt in 1:TT){
    Y <- vector(mode = "list", length = numclust)
    mu <- vector(mode = "list", length = numclust)
    clusters_count <- rmultinom(n = 1, size = ntlist[tt], prob = probs[tt,])

    for(ii in 1:3){
      if(ii == 1){
        mn = means[tt,ii,,drop=TRUE]
        Sigma1 = matrix(rep(0.3, 9), ncol = 3)
        diag(Sigma1) = 0.4
        ## Sigma1 = matrix(c(0.4, 0.3, 0.3, 0.4), ncol = 2)
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0,0), Sigma= Sigma1)) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 2){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0,0), Sigma = diag(c(0.5, 0.1, 0.2)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 3){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0,0), Sigma = diag(c(0.35, 0.35, 0.35)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
    }

    Y <- Y %>% purrr::compact() %>% do.call(rbind, .)
    mu <- mu %>% purrr::compact() %>% do.call(rbind, .)
    cluster <- rep(1:3, times = clusters_count)
    colnames(Y) = paste0("dim", 1:3)
    ylist[[tt]] = Y
    mulist[[tt]] = mu
    clusterlist[[tt]] = cluster
  }
  return(list(ylist = ylist, mulist = mulist,
              clusterlist = clusterlist,
              probs = probs, means = means))
}
```

Now, trying this out on some synthetic data and estimated model.

```{r, eval = FALSE, fig.width = 15, fig.height = 5}
datobj = gendat_3d(100, rep(100,100))
plot_3d(ylist = datobj$ylist, tt = 1)
set.seed(2321)
obj = flowtrend(ylist = datobj$ylist,
                l = 2, l_prob = 1,
                lambda = .01, lambda_prob = .01,
                numclust = 3, verbose = FALSE,
                maxdev = 3,
                niter = 50,
                nrestart = 3)
plot_3d(ylist = datobj$ylist, tt = tt, obj = obj)
```

