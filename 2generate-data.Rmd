# 1d data

## Generating 1d data

This function generates synthetic 1-dimensional data, and returns it in a "long"
format matrix, with columns `time`, `y`, `mu`, and `cluster`. The latter two are
the true underlying parameters.

```{r gendat_1d}
#' Generates some synthetic 1-dimensional data with three clusters. Returns a
#' data frame with (1) time, (2) Y (3) mu (4) cluster assignments.
#'
#' @param TT Number of time points.
#' @param nt Number of particles at each time.
#' @param offset Defaults to 0. How much to push up cluster 1.
#' @param return_model If true, return true cluster means and probabilities
#'   instead of data.
#'
#' @return long matrix with data or model.
#' @export
gendat_1d <- function(TT, ntlist, offset = 0, return_model = FALSE){

  ## Basic checks
  stopifnot(length(ntlist) == TT)

  ## Make cluster probabilities, by time
  cluster_prob1 = sapply(1:TT, function(tt) sin(tt/24 * 2 * pi)/3 + 1 + (tt/TT)*5)
  cluster_prob2 = sapply(1:TT, function(tt) cos(tt/24 * 2 * pi)/3 + 8 - (tt/TT)*5)
  cluster_prob3 = rep(3, TT)
  probs = cbind(cluster_prob1, cluster_prob2, cluster_prob3)
  probs = probs/rowSums(probs)
  colnames(probs) = 1:3
  sd1 = 0.4
  sd2 = 0.5
  sd3 = 0.35
  probs_long = as_tibble(probs) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "prob")
  probs_long %>% ggplot() + geom_line(aes(x=time,y=prob, group=cluster, col=cluster)) + ylim(c(0,1))

  ## Make cluster means, by time
  means <- matrix(NA, TT, 3)
  for(ii in 1:3){
    for(tt in 1:TT){
      means[tt, 1] <- offset + tt/TT - 1.5
      means[tt, 2] <- sin(seq(-1, 1, length.out = TT)[tt] * 3.1415)
      means[tt, 3] <- -3+sin(seq(-1, 1, length.out = TT)[tt] * 6.282)
    }
  }
  colnames(means) = c(1:3)
  means_long = as_tibble(means) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "mean")
  model = full_join(means_long, probs_long, by = c("time", "cluster"))
  model = model %>% left_join(tibble(cluster = c("1", "2", "3"),
                                     sd = c(sd1, sd2, sd3)),
                              by = "cluster") ## Does this work?
  if(return_model) return(model)

  ys <- lapply(1:TT, FUN = function(tt){

    Y <- vector(mode = "list", length = 2)
    mu <- vector(mode = "list", length = 2)
    clusters_count <- rmultinom(n = 1, size = ntlist[tt], prob = probs[tt,])

    for(ii in 1:3){
      if(ii == 1){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd1))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
      if(ii == 2){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd2))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
      if(ii == 3){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd3))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
    }
    Y <- unlist(Y)
    mu <- unlist(mu)
    cluster <- rep(1:3, times = clusters_count)
    one_df = tibble(time = tt, Y = Y, mu = mu, cluster = cluster)
    return(one_df)
  }) %>% bind_rows()
  return(ys)
}
```


`dt2ylist()` is a helper that takes the output generated from `gendat_1d()`, and
splits it by the `time` column to create a `ylist` object, which is a $T$-length
list of $n_t \times d$ matrices.

```{r dt2ylist}
#' Converting to a list of matrices, \code{ylist}, to input to \code{flowtrend()}.
#'
#' @param dt Output from \code{gendat_1d()}.
#'
#' @return List of matrices
#' @export
dt2ylist <- function(dt){
  dt%>% select(time, Y) %>% arrange(time) %>%
    group_by(time) %>%
    group_split(.keep = FALSE) %>%
    lapply(as.matrix)
}
```

Let's generate some data using these functions.

```{r test-generate-data}
dt = gendat_1d(TT = 100, ntlist =rep(100,100))
print(dt)
```

```{r test-ylist}
ylist = dt2ylist(dt)
print(head(str(ylist[1:5])))
```

```{r test-ylist2}
print(head(ylist[[1]]))
```

Next, we'll make some plotting functions 1d model and data.


## Plotting 1d data

Given 1d data `ylist` and an estimated model object `obj`, we want to plot both
in a single plot. `plot_1d()` lets you do this.

```{r plot_1d}
#' Makes 1d plot of data and model
#'
#' @param ylist Data.
#' @param obj flowtrend object. Defaults to NULL.
#' @param x time points. Defaults to NULL.
#'
#' @return ggplot object with data, and optionally, a flowtrend model overlaid.
#' @export
plot_1d <- function(ylist, countslist=NULL, obj=NULL, x = NULL, add_point = FALSE){

  ## Basic checks
  if(!is.null(x)){
    stopifnot(length(x) == length(ylist))
    times = x
  } else {
    times = 1:length(ylist)
  }

  if(is.null(countslist)){
    ## make data into long matrix
    ymat <- lapply(1:length(ylist), FUN = function(tt){
      data.frame(time = times[tt], Y = ylist[[tt]])
    }) %>% bind_rows() %>% as_tibble()

    ## plot long matrix
    gg = ymat %>% ggplot() +
      geom_point(aes(x = time, y = Y), alpha = .1) +
      theme_bw() + ylab("Data") + xlab("Time") 
      ## theme(legend.position = 'none')
  } else {
    ## make data into long matrix
    ymat <- lapply(1:length(ylist), FUN = function(tt){
      data.frame(time = times[tt], Y = ylist[[tt]], counts = countslist[[tt]])
    }) %>% bind_rows() %>% as_tibble()

    ## plot long matrix
    gg = ymat %>% ggplot() +
      geom_raster(aes(x = time, y = Y, fill = counts)) +
      theme_bw() + ylab("Data") + xlab("Time")  +
      scale_fill_gradientn(colours = c("white", "black"))
      ## theme(legend.position = 'none')
  }
  if(is.null(obj)) return(gg)

  ## Add the model
  numclust = obj$numclust
  mnmat = obj$mn %>% .[,1,] %>%  `colnames<-`(1:numclust) %>% as_tibble() %>% 
    add_column(time = times)
  probmat = obj$prob %>% as_tibble() %>% setNames(1:numclust) %>% add_column(time = times)
  mn_long = mnmat %>% pivot_longer(-time, names_to = "cluster", values_to = "mean")
  prob_long = probmat %>% pivot_longer(-time, names_to = "cluster", values_to = "prob")
  est_long = full_join(mn_long, prob_long, by = c("time","cluster"))
  gg = gg + geom_path(aes(x = time, y = mean, linewidth = prob, group = cluster, color = cluster),
                      data = est_long,
                      lineend = "round", linejoin="mitre")
  if(add_point){
    gg = gg + geom_line(aes(x = time, y = mean, linewidth = prob, group = cluster),
                        data = est_long, size = rel(1),
                        col = 'black')
  }

  ## TODO: make it ignore the missing values at the gaps; currently this is not coded as NAs.

  ## Add the estimated 95% probability regions for data.
  stdev = obj$sigma %>% .[,,1] %>% sqrt()
  band_long =
    mn_long %>% mutate(upper = case_when(cluster == "1" ~ mean + 1.96 * stdev[1],
                                         cluster == "2" ~ mean + 1.96 * stdev[2],
                                         cluster == "3" ~ mean + 1.96 * stdev[3]),
                       lower = case_when(cluster == "1" ~ mean - 1.96 * stdev[1],
                                         cluster == "2" ~ mean - 1.96 * stdev[2],
                                         cluster == "3" ~ mean - 1.96 * stdev[3]))
  gg + geom_line(aes(x = time, y = upper, group = cluster, color = cluster),
                 data = band_long, size = rel(1), alpha = .5) +
    geom_line(aes(x = time, y = lower, group = cluster, color = cluster),
              data = band_long, size = rel(1), alpha = .5) +
    guides(size = "none") # To turn off line size from legend
}
```

The plotting function `plot_1d()` will be even more useful when we have a model,
but can also simply plot the data `ylist`. Let's try this out.

```{r test-gendat}
set.seed(100)
dt       <- gendat_1d(100, rep(100, 100))
dt_model <- gendat_1d(100, rep(100, 100), return_model = TRUE)
ylist = dt %>% dt2ylist()
x = dt %>% pull(time) %>% unique()

plot_1d(ylist, NULL, x = x) +
  geom_line(aes(x = time, y = mean, group = cluster),
            data = dt_model,
            linetype = "dashed", size=2, alpha = .7)
```
Voil√†!

Also, we will want to plot the estimated cluster probabilities of a model `obj`.

```{r}
#' Makes cluster probability plot (lines over time).
#'
#' @param obj Estimated model (from e.g. \code{flowtrend()})
#'
#' @export
plot_prob <- function(obj, x = NULL){

  ## Basic checks
  if(!is.null(x)){
    stopifnot(length(x) == length(ylist))
    times = x
  } else {
    times = 1:length(ylist)
  }

  numclust = obj$numclust
  probmat = obj$prob %>% as_tibble() %>% setNames(1:numclust) %>% add_column(time = times)
  prob_long = probmat %>% pivot_longer(-time, names_to = "cluster", values_to = "prob")
  prob_long %>% ggplot() +
    geom_line(aes(x=time, y = prob, group = cluster, col = cluster), size = rel(1)) +
    ggtitle("Estimated cluster probability")
}
```

We can't test it out now, but we'll use it later in [1d-example](#1d-example).


# 2d data

## Generating 2d data


```{r gendat_2d}
#' Generates some synthetic 2-dimensional data with three clusters. 
#'
#' @param TT Number of time points.
#' @param nt Number of particles at each time.
#'
#' @return List containing (1) ylist, (2) mnlist, (3) clusterlist.
#' @export
gendat_2d <- function(TT, ntlist){


  ## Basic checks
  stopifnot(length(ntlist) == TT)

  ## Make cluster probabilities, by time
  cluster_prob1 = sapply(1:TT, function(tt) sin(tt/24 * 2 * pi)/3 + 1 + (tt/TT)*5)
  cluster_prob2 = sapply(1:TT, function(tt) cos(tt/24 * 2 * pi)/3 + 8 - (tt/TT)*5)
  cluster_prob3 = rep(3, TT)
  probs = cbind(cluster_prob1, cluster_prob2, cluster_prob3)
  probs = probs/rowSums(probs)
  colnames(probs) = 1:3
  probs_long = as_tibble(probs) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "prob")
  probs_long %>% ggplot() + geom_line(aes(x=time,y=prob, group=cluster, col=cluster)) + ylim(c(0,1))

  ## Make cluster means, by time
  means <- array(NA, dim = c(TT, 3, 2))
  for(ii in 1:3){
    for(tt in 1:TT){
      means[tt, 1, 1] = means[tt, 1, 2] = tt/TT + 0.5
      means[tt, 2, 1]  = sin(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*3.1415)
      means[tt, 2, 2] = 0
      means[tt, 3, 1] = means[tt, 3, 2] = -3+cos(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*6.282)
    }
  }
  dimnames(means)[[2]]  = c(1:3)
  means_long = as_tibble(means) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "mean")
  model = full_join(means_long, probs_long, by = c("time", "cluster"))

  ylist = list()
  mulist = list()
  clusterlist = list()
  for(tt in 1:TT){
    Y <- vector(mode = "list", length = 2)
    mu <- vector(mode = "list", length = 2)
    clusters_count <- rmultinom(n = 1, size = ntlist[tt], prob = probs[tt,])

    for(ii in 1:3){
      if(ii == 1){
        mn = means[tt,ii,,drop=TRUE]
        Sigma1 = matrix(c(0.4, 0.3, 0.3, 0.4), ncol = 2)
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma= Sigma1)) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 2){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma = diag(c(0.5, 0.1)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 3){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma = diag(c(0.35, 0.35)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
    }

    Y <- Y %>% purrr::compact() %>% do.call(rbind, .)
    mu <- mu %>% purrr::compact() %>% do.call(rbind, .)
    cluster <- rep(1:3, times = clusters_count)
    ylist[[tt]] = Y
    mulist[[tt]] = mu
    clusterlist[[tt]] = cluster
  }
  return(list(ylist = ylist, mulist = mulist, clusterlist = clusterlist, probs = probs, means = means))
}
```


## Plotting 2d data

Here's a simpler plotting function for 2d data at the particle level.

```{r}
#' Simple plotter for 2d particle data.
plot_2d <- function(ylist, tt){

  ## Get data from one timepoint
  y = ylist %>% .[[tt]]
  y = y %>% as_tibble()
  colnames(y) = paste0("dim", c(1,2))

  ## Make a simple scatterplot
  y %>% ggplot() +
    geom_point(aes(x=dim1, y=dim2), alpha = .3) +
    theme_minimal() +
    coord_fixed()
}
```

Let's try it out.

```{r, fig.width = 5, fig.height = 5}
datobj = gendat_2d(2, c(1000,1000))
plot_2d(datobj$ylist, 1)
```
