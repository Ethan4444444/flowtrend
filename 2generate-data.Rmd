# 1d data

## Generating 1d data

This function generates synthetic 1-dimensional data, and returns it in a "long"
format matrix, with columns `time`, `y`, `mu`, and `cluster`. The latter two are
the true underlying parameters.

```{r gendat_1d}
#' Generates some synthetic 1-dimensional data with three clusters. Returns a
#' data frame with (1) time, (2) Y (3) mu (4) cluster assignments.
#'
#' @param TT Number of time points.
#' @param nt Number of particles at each time.
#' @param offset Defaults to 0. How much to push up cluster 1.
#' @param return_model If true, return true cluster means and probabilities
#'   instead of data.
#'
#' @return long matrix with data or model.
#' @export
gendat_1d <- function(TT, ntlist, offset = 0, return_model = FALSE,
                      sd3=NULL){

  ## Basic checks
  stopifnot(length(ntlist) == TT)


  ## ## Temporary
  ## prob_link = cbind(1:10, (11:2)/2)
  ## matplot(prob_link)
  ## probs = exp(prob_link[,1])/(exp(prob_link[,2]) + exp(prob_link[,1]))  
  ## plot(probs)
  ## diff(probs) %>% plot()
  ## ## End of temporary

  ## Make cluster probabilities, by time
  ## cluster_prob1 = sapply(1:TT, function(tt) 1 + (tt/TT) * 5)
  ## cluster_prob2 = sapply(1:TT, function(tt) 8 - (tt/TT) * 5)
  ## cluster_prob3 = rep(3, TT)
  ## TT = 100
  ## prob_link1_1 = sapply(1:TT, function(tt){ 3 + (tt/TT) })
  ## prob_link1_2 = sapply(1:TT, function(tt){ 4 - (tt/TT)*2 })
  ## prob_link1 = pmin(prob_link1_1, prob_link1_2)
  ## plot(prob_link1)
  prob_link1 = rep(NA, TT)
  prob_link1[1] = 2
  for(tt in 2:floor(TT/2)){
    prob_link1[tt] = prob_link1[tt-1] + (1/TT)
  }
  for(tt in (floor(TT/2)+1):TT){
    prob_link1[tt] = prob_link1[tt-1] - .5*(1/TT)
  }
  prob_link2 = sapply(1:TT, function(tt) 3 - 0.25*(tt/TT))
  prob_link3 = sapply(1:TT, function(tt) 2.5)
  linkmat = cbind(prob_link1, prob_link2, prob_link3) ##%>% matplot()
  mysum = exp(linkmat) %>% rowSums()
  cluster_prob1 = exp(prob_link1) / mysum
  cluster_prob2 = exp(prob_link2) / mysum
  cluster_prob3 = exp(prob_link3) / mysum
  probs = cbind(cluster_prob1, cluster_prob2, cluster_prob3)
  colnames(probs) = 1:3
  sd1 = 0.4
  sd2 = 0.5
  if(is.null(sd3)) sd3 = 0.35
  ## if(!is.null(sd3)) sd3 = 1/1.5 ## The ratio of amplitude:data-standard-deviation is about
  ##             ## $1.50695$.
  probs_long = as_tibble(probs) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "prob")
  probs_long %>% ggplot() + geom_line(aes(x=time,y=prob, group=cluster, col=cluster)) + ylim(c(0,1))

  ## Make cluster means, by time
  means <- matrix(NA, TT, 3)
  for(ii in 1:3){
    for(tt in 1:TT){
      means[tt, 1] <- offset + tt/TT - 1.5
      means[tt, 2] <- sin(seq(-1, 1, length.out = TT)[tt] * 3.1415)
      means[tt, 3] <- -3+sin(seq(-1, 1, length.out = TT)[tt] * 6.282)
    }
  }
  colnames(means) = c(1:3)
  means_long = as_tibble(means) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "mean")
  model = full_join(means_long, probs_long, by = c("time", "cluster"))
  model = model %>% left_join(tibble(cluster = c("1", "2", "3"),
                                     sd = c(sd1, sd2, sd3)),
                              by = "cluster") ## Does this work?
  if(return_model) return(model)

  ys <- lapply(1:TT, FUN = function(tt){

    Y <- vector(mode = "list", length = 2)
    mu <- vector(mode = "list", length = 2)
    clusters_count <- rmultinom(n = 1, size = ntlist[tt], prob = probs[tt,])

    for(ii in 1:3){
      if(ii == 1){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd1))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
      if(ii == 2){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd2))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
      if(ii == 3){
        mn = means[tt,ii, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + rnorm(1, mean=0, sd = sd3))
        mu[[ii]] <- rep(mn, clusters_count[ii,1])
      }
    }
    Y <- unlist(Y)
    mu <- unlist(mu)
    cluster <- rep(1:3, times = clusters_count)
    one_df = tibble(time = tt, Y = Y, mu = mu, cluster = cluster)
    return(one_df)
  }) %>% bind_rows()
  return(ys)
}
```


`dt2ylist()` is a helper that takes the output generated from `gendat_1d()`, and
splits it by the `time` column to create a `ylist` object, which is a $T$-length
list of $n_t \times d$ matrices.

```{r dt2ylist}
#' Converting to a list of matrices, \code{ylist}, to input to \code{flowtrend()}.
#'
#' @param dt Output from \code{gendat_1d()}.
#'
#' @return List of matrices
#' @export
dt2ylist <- function(dt){
  dt%>% dplyr::select(time, Y) %>% arrange(time) %>%
    group_by(time) %>%
    group_split(.keep = FALSE) %>%
    lapply(as.matrix)
}
```

Let's generate some data using these functions.

```{r test-generate-data}
dt = gendat_1d(TT = 100, ntlist =rep(100,100))
print(dt)
```

```{r test-ylist}
ylist = dt2ylist(dt)
print(head(str(ylist[1:5])))
```

```{r test-ylist2}
print(head(ylist[[1]]))
```

Next, we'll make some plotting functions 1d model and data.


## Plotting 1d data

Given 1d data `ylist` and an estimated model object `obj`, we want to plot both
in a single plot. `plot_1d()` lets you do this.

```{r plot_1d}
#' Makes 1d plot of data and model
#'
#' @param ylist Data.
#' @param obj flowtrend object. Defaults to NULL.
#' @param x time points. Defaults to NULL.
#' @param add_point if TRUE, add the means as points.
#' @param idim if provided, take the idim.
#'
#' @return ggplot object with data, and optionally, a flowtrend model overlaid.
#' @export
plot_1d <- function(ylist, countslist=NULL, obj=NULL, x = NULL, add_point = FALSE, idim = NULL, alpha = .1){

  ## Basic checks
  if(!is.null(x)){
    stopifnot(length(x) == length(ylist))
    times = x
  } else {
    times = 1:length(ylist)
  }


  ## If more than 2d data is provided, take the idim'th info only.
  dimdat = ncol(ylist[[1]])
  if(dimdat >= 2){
    assertthat::assert_that(!is.null(idim))
    assertthat::assert_that(idim %in% 1:dimdat)

    if(!is.null(obj)){
      obj$mn = obj$mn %>% .[,idim,,drop=FALSE]
      obj$sigma = obj$sigma %>% .[,idim,idim,drop=FALSE]
    }
    ylist = ylist %>% lapply(function(a) a[,idim, drop=FALSE])
  }

  if(is.null(countslist)){
    ## make data into long matrix
    ymat <- lapply(1:length(ylist), FUN = function(tt){
      data.frame(time = times[tt], Y = ylist[[tt]])
    }) %>% bind_rows() %>% as_tibble()
    colnames(ymat) = c("time", "Y", "counts") ## when ylist[[tt]] already has a column name, this is needed.

    ## plot long matrix
    gg = ymat %>% ggplot() +
      geom_point(aes(x = time, y = Y), alpha = alpha) +
      theme_bw() + ylab("Data") + xlab("Time") 
      ## theme(legend.position = 'none')
  } else {
    ## make data into long matrix
    ymat <- lapply(1:length(ylist), FUN = function(tt){
      data.frame(time = times[tt], Y = ylist[[tt]], counts = countslist[[tt]])
    }) %>% bind_rows() %>% as_tibble()
    colnames(ymat) = c("time", "Y", "counts") ## when ylist[[tt]] already has a column name, this is needed.

    ## plot long matrix
    gg = ymat %>% ggplot() +
      geom_raster(aes(x = time, y = Y, fill = counts)) +
      theme_bw() + ylab("Data") + xlab("Time")  +
      scale_fill_gradientn(colours = c("white", "black"))
      ## theme(legend.position = 'none')
  }
  if(is.null(obj)){
    return(gg)
  } else {
  
    ## Add the model
    numclust = obj$numclust
    mnmat = obj$mn %>% .[,1,] %>%  `colnames<-`(1:numclust) %>% as_tibble() %>% 
      add_column(time = times)
    probmat = obj$prob %>% as_tibble() %>% setNames(1:numclust) %>% add_column(time = times)
    mn_long = mnmat %>% pivot_longer(-time, names_to = "cluster", values_to = "mean")
    prob_long = probmat %>% pivot_longer(-time, names_to = "cluster", values_to = "prob")
    est_long = full_join(mn_long, prob_long, by = c("time","cluster"))
    gg = gg + geom_path(aes(x = time, y = mean, linewidth = prob, group = cluster, color = cluster),
                        data = est_long,
                        lineend = "round", linejoin="mitre")
    if(add_point){
      gg = gg + geom_line(aes(x = time, y = mean, linewidth = prob, group = cluster),
                          data = est_long, size = rel(1),
                          col = 'black')
    }
  
    ## TODO: make it ignore the missing values at the gaps; currently this is not coded as NAs.
  
    ## Add the estimated 95% probability regions for data.
    stdev = obj$sigma %>% .[,,1] %>% sqrt()
    ## band_long =
    ##   mn_long %>% mutate(upper = case_when(cluster == "1" ~ mean + 1.96 * stdev[1],
    ##                                        cluster == "2" ~ mean + 1.96 * stdev[2],
    ##                                        cluster == "3" ~ mean + 1.96 * stdev[3]),
    ##                      lower = case_when(cluster == "1" ~ mean - 1.96 * stdev[1],
    ##                                        cluster == "2" ~ mean - 1.96 * stdev[2],
    ##                                        cluster == "3" ~ mean - 1.96 * stdev[3]))

    mn_long_by_clust = mn_long %>% group_by(cluster) %>% group_split()
    band_long_by_clust = lapply(1:numclust, function(iclust){
      mn_long_by_clust[[iclust]] %>% mutate(upper = mean + 1.96 * stdev[iclust]) %>% mutate(lower = mean - 1.96 * stdev[iclust])
    })
    band_long = band_long_by_clust %>% bind_rows()


    gg + geom_line(aes(x = time, y = upper, group = cluster, color = cluster),
                   data = band_long, size = rel(.7), alpha = .5) +
      geom_line(aes(x = time, y = lower, group = cluster, color = cluster),
                data = band_long, size = rel(.7), alpha = .5) +
      guides(size = "none") # To turn off line size from legend
  }
}
```

The plotting function `plot_1d()` will be even more useful when we have a model,
but can also simply plot the data `ylist`. Let's try this out.

```{r test-gendat}
set.seed(100)
dt       <- gendat_1d(100, rep(100, 100))
dt_model <- gendat_1d(100, rep(100, 100), return_model = TRUE)
ylist = dt %>% dt2ylist()
x = dt %>% pull(time) %>% unique()

plot_1d(ylist, NULL, x = x) +
  geom_line(aes(x = time, y = mean, group = cluster),
            data = dt_model,
            linetype = "dashed", size=2, alpha = .7)
```
Voilà!

Also, we will want to plot the estimated cluster probabilities of a model `obj`.

```{r}
#' Makes cluster probability plot (lines over time).
#'
#' @param obj Estimated model (from e.g. \code{flowtrend()})
#'
#' @export
plot_prob <- function(obj, x = NULL){

  ## Basic checks
  if(!is.null(x)){
    times = x
  } else {
    stop("must provide x")
    times = 1:length(ylist)
  }

  numclust = obj$numclust
  probmat = obj$prob %>% as_tibble() %>% setNames(1:numclust) %>% add_column(time = times)
  prob_long = probmat %>% pivot_longer(-time, names_to = "cluster", values_to = "prob")
  prob_long %>% ggplot() +
    geom_line(aes(x=time, y = prob, group = cluster, col = cluster), size = rel(1)) +
    ggtitle("Estimated cluster probability")
}
```

We can't test it out now, but we'll use it later in [1d-example](#1d-example).



# 2d data

## Generating 2d data


```{r gendat_2d}
#' Generates some synthetic 2-dimensional data with three clusters. 
#'
#' @param TT Number of time points.
#' @param nt Number of particles at each time.
#'
#' @return List containing (1) ylist, (2) mnlist, (3) clusterlist.
#' @export
gendat_2d <- function(TT, ntlist){


  ## Basic checks
  stopifnot(length(ntlist) == TT)

  ## Make cluster probabilities, by time
  cluster_prob1 = sapply(1:TT, function(tt) sin(tt/24 * 2 * pi)/3 + 1 + (tt/TT)*5)
  cluster_prob2 = sapply(1:TT, function(tt) cos(tt/24 * 2 * pi)/3 + 8 - (tt/TT)*5)
  cluster_prob3 = rep(3, TT)
  probs = cbind(cluster_prob1, cluster_prob2, cluster_prob3)
  probs = probs/rowSums(probs)
  colnames(probs) = 1:3
  probs_long = as_tibble(probs) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "prob")
  probs_long %>% ggplot() + geom_line(aes(x=time,y=prob, group=cluster, col=cluster)) + ylim(c(0,1))

  ## Make cluster means, by time
  means <- array(NA, dim = c(TT, 3, 2))
  for(ii in 1:3){
    for(tt in 1:TT){
      means[tt, 1, 1] = means[tt, 1, 2] = tt/TT + 0.5
      means[tt, 2, 1]  = sin(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*3.1415)
      means[tt, 2, 2] = 0
      means[tt, 3, 1] = means[tt, 3, 2] = -3+cos(tt/24 * 2 * pi)##seq(-1, 1, length.out = TT)[tt]*6.282)
    }
  }
  dimnames(means)[[2]]  = c(1:3)
  means_long = as_tibble(means) %>%
    add_column(time = 1:TT) %>%
    pivot_longer(-"time", names_to = "cluster", values_to = "mean")
  model = full_join(means_long, probs_long, by = c("time", "cluster"))

  ylist = list()
  mulist = list()
  clusterlist = list()
  for(tt in 1:TT){
    Y <- vector(mode = "list", length = 2)
    mu <- vector(mode = "list", length = 2)
    clusters_count <- rmultinom(n = 1, size = ntlist[tt], prob = probs[tt,])

    for(ii in 1:3){
      if(ii == 1){
        mn = means[tt,ii,,drop=TRUE]
        Sigma1 = matrix(c(0.4, 0.3, 0.3, 0.4), ncol = 2)
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma= Sigma1)) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 2){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma = diag(c(0.5, 0.1)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
      if(ii == 3){
        mn = means[tt,ii,, drop=TRUE]
        Y[[ii]] <- replicate(clusters_count[ii,1], mn + MASS::mvrnorm(1, mu=c(0,0), Sigma = diag(c(0.35, 0.35)))) %>% t()
        mu[[ii]] <- replicate(clusters_count[ii,1], mn) %>% t()
      }
    }

    Y <- Y %>% purrr::compact() %>% do.call(rbind, .)
    mu <- mu %>% purrr::compact() %>% do.call(rbind, .)
    cluster <- rep(1:3, times = clusters_count)
    ylist[[tt]] = Y
    mulist[[tt]] = mu
    clusterlist[[tt]] = cluster
  }
  return(list(ylist = ylist, mulist = mulist, clusterlist = clusterlist, probs = probs, means = means))
}
```


## Plotting 2d data

Here's a simpler plotting function for 2d data at the particle level.

```{r}
#' Simple plotter for 2d particle data.
plot_2d <- function(ylist, obj = NULL, tt){

  ## Basic checks
  stopifnot(ncol(ylist[[1]]) == 2)
  if(!is.null(obj)) stopifnot(obj$dimdat == 2)

  ## Get data from one timepoint
  y = ylist %>% .[[tt]]
  y = y %>% as_tibble()
  colnames(y) = paste0("dim", c(1,2))

  ## Make a simple scatterplot
  p = y %>% ggplot() +
    geom_point(aes(x=dim1, y=dim2), alpha = .2) +
    theme_minimal() +
    coord_fixed()


  p = p + ggtitle(paste0("Time=", tt)) +
    coord_cartesian(xlim = c(-6.5, 2.5), ylim = c(-6.5, 2.5)) +
    theme_minimal()

  ## Adding visualizations of the model |obj|
  if(is.null(obj)){
    return(p)
  } else {
    mnlist = lapply(1:obj$numclust, function(iclust){
      one_mnmat = obj$mn[,,iclust]
      colnames(one_mnmat) = paste0("dim", 1:2)
      one_mnmat %>% as_tibble() %>% add_column(cluster = iclust)
    })
    mnmat = do.call(rbind, mnlist)

    mn_colours = rep("red", 3)
    for(iclust in 1:obj$numclust){

      ## Add ellipse
      el = ellipse::ellipse(x = obj$sigma[iclust,,],
                            centre = obj$mn[tt,,iclust]) %>% as_tibble()
      p = p + geom_path(aes(x = x, y = y), data = el,
                        colour = mn_colours[iclust], lty = 2,
                        lwd = pmin(obj$prob[tt,iclust] * 8, 0.8))

      ## Add mean
      p = p + geom_point(aes(x = dim1, y = dim2),
                         data = mnmat %>% subset(cluster == iclust) %>% .[tt,],
                         colour = mn_colours[iclust],
                         ## size = rel(3))
                         size = obj$prob[tt,iclust] * 10)
    }
  }
  return(p)
}
```

Let's try it out.

```{r, fig.width = 5, fig.height = 5}
datobj = gendat_2d(2, c(1000,1000))
plot_2d(datobj$ylist, tt=1)
```

