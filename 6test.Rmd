# Testing the flowtrend method

We're going to assume the `flowtrend()` function has been built, and test it
now.

## 1d example {#1d-example}


Generate data.

```{r 1d-example, eval = FALSE}
set.seed(100)
dt       <- gendat_1d(100, rep(100, 100))
dt_model <- gendat_1d(100, rep(100, 100), return_model = TRUE)
ylist = dt %>% dt2ylist()
x = dt %>% pull(time) %>% unique()
plot_1d(ylist)
```

Next, we fit the model.

```{r 1d-example2, eval = FALSE}
set.seed(18)
obj <- flowtrend(ylist = ylist,
                 x = x,
                 maxdev = 5,
                 numclust = 3,
                 l = 2,
                 l_prob = 2,
                 lambda = 1,
                 lambda_prob = .1,
                 admm_local_adapt = TRUE,
                 nrestart = 1,
                 verbose = TRUE)

## Also reorder the cluster labels of the truth, to match the fitted model.
ord = obj$mn[,1,] %>% colSums() %>% order(decreasing=TRUE)
lookup <- setNames(c(1:obj$numclust), ord)
dt_model$cluster = lookup[as.numeric(dt_model$cluster)] %>% as.factor()

## Reorder the cluster lables of the fitted model.
obj = reorder_clust(obj)
```

The data and estimated model are shown here. The dashed lines are the true means.


```{r 1d-example-plot-mean, fig.width = 7, fig.height = 5, eval = FALSE}
plot_1d(ylist, obj, x = x, add_point = FALSE) +
  geom_line(aes(x = time, y = mean, group = cluster),
            data = dt_model,## %>% subset(time %ni% held_out),
            linetype = "dashed", size=2, alpha = .7)
```

The estimated probabilities are shown here.

```{r 1d-example-plot-prob, fig.width = 7, fig.height = 5, eval = FALSE}
plot_prob(obj) +
  geom_line(aes(x = time, y = prob, group = cluster, color = cluster),
            data = dt_model, linetype = "dashed")  +
  facet_wrap(~cluster)
```



## Testing monotonicity of objective values

The objective value (that is, the penalized log likelihood) should be monotone
decreasing across EM algorithm iterations.

(Note: because the admm is imperfect and stops early sometimes, the objective is
sometimes non-monotone. See the example from a few sections up!)

```{r test-objective, fig.width = 5, fig.height = 3, eval = FALSE}
testthat::test_that("Objective value decreases over EM iterations.",{
  
  for(iseed in 1:5){
    print(iseed)
    
    ## Generate synthetic data
    set.seed(iseed*100)
    dt       <- gendat_1d(100, rep(10, 100))
    dt_model       <- gendat_1d(100, rep(10, 100), return_model = TRUE)
    ylist = dt %>% dt2ylist()
    x = dt %>% pull(time) %>% unique()
    
    ## Fit model
    obj <- flowtrend(ylist = ylist,
                     x = x,
                     maxdev = 5,
                     numclust = 3,
                     lambda = 0.02,
                     l = 1,
                     l_prob = 2,
                     lambda_prob = 0.05,
                     nrestart = 1,
                     verbose=TRUE)

    ## Test objective monotonicity
    niter_end = length(obj$objective)
    ## testthat::expect_true(all(diff(obj$objective) < 1E-4))

    ## Make a plot
    g = ggplot(tibble(iter=1:niter_end, objective=obj$objectives)) +
      geom_point(aes(x=iter, y=objective)) +
      geom_line(aes(x=iter, y=objective)) +
      ggtitle(paste0("Seed=", iseed*100))
    print(g)
  }
})
```

## 2d example {#2d-example}

Next, we try out `flowtrend` on a synthetic 2d data example.

```{r 2d-example, fig.width = 10, fig.width = 6, eval = FALSE}
set.seed(100) 
dt       <- gendat_2d(100, rep(100, 100))
set.seed(10)
obj <- flowtrend(ylist = dt$ylist,
                 maxdev = 5,
                 numclust = 3,
                 lambda = 0.02,
                 l = 1,
                 l_prob = 2,
                 lambda_prob = .005,
                 nrestart = 3)

## Put together means into a long data frame
numclust = 3
mnlist = lapply(1:numclust, function(iclust){
  one_mnmat = obj$mn[,,iclust]
  colnames(one_mnmat) = paste0("dim", 1:2)
  one_mnmat %>% as_tibble() %>% add_column(cluster = iclust)
})
mnmat = do.call(rbind, mnlist)


## Show estimated model at six time points. 
timelist = c(10, 30,40,50,60,70)
plist = lapply(timelist, function(tt){
  y = dt$ylist[[tt]] %>% as_tibble()
  colnames(y) = paste0("dim", 1:2) 
  p = y %>% ggplot() + geom_point(aes(x=dim1, y=dim2), alpha =.2)
  numclust = 3
  mn_colours = rep("red", 3)
  for(iclust in 1:numclust){
    ## Add ellipse
    el = ellipse::ellipse(x = obj$sigma[iclust,,], centre = obj$mn[tt,,iclust]) %>% as_tibble()
    p = p + geom_path(aes(x = x, y = y), data = el, colour = mn_colours[iclust], lty = 2,
                      lwd = pmin(obj$prob[tt,iclust] * 8, 0.8))

    ## Add mean
    p = p + geom_point(aes(x = dim1, y = dim2),
                       data = mnmat %>% subset(cluster == iclust) %>% .[tt,],
                       colour = mn_colours[iclust],
                       ## size = rel(3))
                       size = obj$prob[tt,iclust] * 10)
  }
  p = p + ggtitle(paste0("Time=", tt)) +
    coord_cartesian(xlim = c(-6.5, 2.5), ylim = c(-6.5, 2.5)) +
    theme_minimal()
  return(p)
})

library(ggpubr)
do.call(ggarrange, c(plist, ncol=3, nrow=2))
```


# Documenting the package and building

We finish by running commands that will document, build, and install the package.  It may also be a good idea to check the package from within this file.

```{r, results='hide'}
litr::document() # <-- use instead of devtools::document()
```
